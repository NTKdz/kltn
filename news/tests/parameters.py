# # parameters.py
# nu = 0.1  # Probability jammer is idle
# arrival_rate = 3  # Data arrival rate (Poisson)
# nu_p = [0.6, 0.2, 0.2]  # Jamming power level probabilities
# d_t = 1  # Packets per active transmission
# e_t = 1  # Energy per packet
# d_bj_arr = [1, 2, 3]  # Backscatter packets per jamming level
# e_hj_arr = [1, 2, 3]  # Harvested energy per jamming level
# dt_ra_arr = [2, 1, 0]  # Rate adaptation packets per jamming level
# d_queue_size = 10  # Data queue capacity
# e_queue_size = 10  # Energy queue capacity
# b_dagger = 3  # Fixed backscatter packets
# num_users = 2  # Number of users (multi-user case)
# num_actions = 7  # Actions: idle, transmit, harvest, backscatter, RA1, RA2, RA3
# num_features = 1 + 2 * num_users  # Jammer state + (data, energy) per user
# num_features_single = 3  # Jammer state + data + energy (single-user)
# memory_size = 10000
# batch_size = 52
# learning_rate_deepQ = 0.0001
# gamma_deepQ = 0.99
# T = 1000000  # Training iterations
# step = 1000  # Print interval

# parameters.py
nu = 0.1
arrival_rate = 3
nu_p = [0.6, 0.2, 0.2]
d_t = 1
e_t = 1
d_bj_arr = [1, 2, 3]
e_hj_arr = [1, 2, 3]
dt_ra_arr = [2, 1, 0]
d_queue_size = 10
e_queue_size = 10
b_dagger = 3
num_users = 4
num_actions = 7
num_states = 2 * (d_queue_size + 1) * (e_queue_size + 1)  # Discrete states per user
num_features = 1 + 2 * num_users  # DQL multi-user
num_features_single = 3  # DQL single-user
memory_size = 10000
batch_size = 52
learning_rate_deepQ = 0.0001
gamma_deepQ = 0.99
learning_rate_Q = 0.1  # Q-learning learning rate
gamma_Q = 0.9  # Q-learning discount factor
T = 1000000
step = 1000